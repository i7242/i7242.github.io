<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_lanyon.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/bdx.png"> <title>K-Means</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p> Find more ... </p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">Home</a> <a class=sidebar-nav-item  href="https://github.com/i7242">GitHub</a> <a class=sidebar-nav-item  href="https://scholar.google.com/citations?user=x8k-UiMAAAAJ&hl=zh-CN">Google Scholar</a> </nav> <div class=sidebar-item > <p>&copy; i7242 | Xingyu Yan.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/" title=Home >i7242 | Xingyu Yan</a> <small>一吃一大碗， 一睡一整天</small> </h3> </div> </div> <div class="container content"> <div class=franklin-content > <h1 id=k-means_clustering ><a href="#k-means_clustering" class=header-anchor >K-means Clustering</a></h1> <div class=franklin-toc ><ol><li><a href="#assumptions">Assumptions</a><li><a href="#get_some_test_data_sets">Get Some Test Data Sets</a><li><a href="#the_algorithm">The Algorithm</a><li><a href="#test">Test</a></ol></div> <h2 id=assumptions ><a href="#assumptions" class=header-anchor >Assumptions</a></h2> <p>This is just an implementation of K-means algorithm. It is not intented to have a generic API, but I can improve it in a later time.</p> <p>Assume inputs are represented as <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> matrix, where:</p> <ul> <li><p>each column is a data point</p> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> is the dimension of vector</p> <li><p><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> is the number of points</p> </ul> <h2 id=get_some_test_data_sets ><a href="#get_some_test_data_sets" class=header-anchor >Get Some Test Data Sets</a></h2> <p>Befor coding, we can generate some test data for later use. Following code randomly sample centrics in a region, then generate data points around centrics. It is easy to observe the square shape around the boundary, but for our purpose this doesn&#39;t matter.</p> <pre><code class="julia hljs"><span class=hljs-comment >#=
  get random point set represented as array of real numbers
    Attention: these parameters are only used to generate random points,
      they are not constraints on results!
    n: number of points to generate
    d: dimension of points
    r: radius around zero point
    k: number of groups (can&#x27;t be guaranteed actually, just random generated)
    σ: deviation for points around k centers
=#</span>

<span class=hljs-keyword >function</span> get_random_points(n::<span class=hljs-built_in >Int64</span>, d::<span class=hljs-built_in >Int64</span>=<span class=hljs-number >2</span>, r::<span class=hljs-built_in >Int64</span>=<span class=hljs-number >4</span>,
        k::<span class=hljs-built_in >Int64</span>=<span class=hljs-number >2</span>, σ::<span class=hljs-built_in >Float64</span>=<span class=hljs-number >1.0</span>)::<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>, <span class=hljs-number >2</span>}, <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>, <span class=hljs-number >2</span>}}
    
    centroids = (rand(<span class=hljs-built_in >Float64</span>, (d, k)) .-<span class=hljs-number >0.5</span>) .* r
    deviations = rand(<span class=hljs-built_in >Float64</span>, (d, n)) .* σ
    sub_count = floor(<span class=hljs-built_in >Int</span>, n/k)
    <span class=hljs-keyword >for</span> idx <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(deviations)[<span class=hljs-number >2</span>]
        deviations[:,idx] .+= centroids[:, min(ceil(<span class=hljs-built_in >Int</span>, idx/sub_count), k)]
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> deviations, centroids
<span class=hljs-keyword >end</span></code></pre> <h2 id=the_algorithm ><a href="#the_algorithm" class=header-anchor >The Algorithm</a></h2> <p>The algorithm is actually not long. Given matrix of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \times n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">m</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> as point set, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> is the dimension of data, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> is the number of points. Also provides how many clusters we want to get, e.g. <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span>.</p> <p>The algoritm first randomly pick <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> centroids and assign each point to a cluster, then it iterates as following:</p> <ul> <li><p>update the cluster assignment</p> <ul> <li><p>for each point, calculate its distance to all centroids</p> <li><p>find the cloest centroid, assign the point to that cluster</p> </ul> <li><p>update the centroids</p> <ul> <li><p>for every centroid, calculate its possition using the latest points assigned to it</p> </ul> </ul> <p>The iteration stopes when the assignment does not change between two iterations, or reaches a limit.</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> k_means_clustering(points::<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>, <span class=hljs-number >2</span>}, k::<span class=hljs-built_in >Int</span>)::<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Int64</span>,<span class=hljs-number >1</span>}
    new_tags = rand(<span class=hljs-number >1</span>:k,size(points)[<span class=hljs-number >2</span>])
    old_tags = zeros(<span class=hljs-built_in >Int64</span>, k)
    centroids = rand(<span class=hljs-built_in >Float64</span>, (size(points)[<span class=hljs-number >1</span>], k))
    iterations = <span class=hljs-number >0</span>
    <span class=hljs-keyword >while</span> new_tags != old_tags &amp;&amp; iterations &lt; <span class=hljs-number >5000</span>
        iterations += <span class=hljs-number >1</span>
        old_tags = copy(new_tags)
        <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(points)[<span class=hljs-number >2</span>]
            new_tags[i] = argmin(sqrt.(sum((centroids .- points[:,i]).^<span class=hljs-number >2</span>, dims=<span class=hljs-number >1</span>)))[<span class=hljs-number >2</span>]
        <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:k
            centroids[:, i] = sum(points[:, new_tags .== i], dims=<span class=hljs-number >2</span>)/
                size(findall(x-&gt;x==i, new_tags))[<span class=hljs-number >1</span>]
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >return</span> new_tags
<span class=hljs-keyword >end</span></code></pre> <h2 id=test ><a href="#test" class=header-anchor >Test</a></h2> <p>Running aboved defined functions we can generate data then clustering it. The results are ploted:</p> <pre><code class="julia hljs">points, centroids = get_random_points(<span class=hljs-number >100</span>, <span class=hljs-number >2</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>)
tags = k_means_clustering(points, <span class=hljs-number >3</span>)</code></pre> <p><img src="/assets/k-means-before.png" alt="Points before clustering" /></p> <ul> <li><p>Points before clustering. The 3 red points are the random base points when generating the point set.</p> </ul> <p><img src="/assets/k-means-after.png" alt="Points before clustering" /></p> <ul> <li><p>Points clustered and assigned with colors.</p> </ul> <div class=page-foot > <div class=copyright > &copy; i7242 | Xingyu Yan. Last modified: February 09, 2023. Website built with <a href="https://julialang.org">Julia</a> and <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>. </div> </div> </div> </div> </div> <label for=sidebar-checkbox  class=sidebar-toggle ></label>